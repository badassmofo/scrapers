//
//  gif.h
//  gif_maker
//
//  Created by Rory B. Bellows on 19/06/2018.
//  Copyright Â© 2018 Rory B. Bellows. All rights reserved.
//

#ifndef GIF_HEADER_H
#define GIF_HEADER_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#ifdef _WIN32
#include <io.h>
#else
#include <unistd.h>
#endif
#include <stdint.h>
#include <stdarg.h>

typedef struct ge_GIF {
  uint16_t w, h;
  int depth;
  int fd;
  int offset;
  int nframes;
  uint8_t *frame, *back;
  uint32_t partial;
  uint8_t buffer[0xFF];
} ge_GIF;

/* helper to write a little-endian 16-bit number portably */
#define write_num(fd, n) write((fd), (uint8_t []) {(n) & 0xFF, (n) >> 8}, 2)

uint8_t color_map[] = {
  0x28, 0x2A, 0x2E, // 0 -> Black
  0xA5, 0x42, 0x42, // 1 -> Red
  0x5F, 0x81, 0x9D, // 2 -> Blue
  0x8C, 0x94, 0x40, // 3 -> Green,
  0xDE, 0x93, 0x5F, // 4 -> Orange
  0x85, 0x67, 0x8F, // 5 -> Magenta
  0x5E, 0x8D, 0x87, // 6 -> Cyan
  0xC5, 0xC8, 0xC6, // 7 -> White
};

typedef enum {
  BLACK,
  RED,
  BLUE,
  GREEN,
  ORANGE,
  MAGENTA,
  CYAN,
  WHITE
} COLOR;

static char font[128][8] = {
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0000 (nul)
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0001
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0002
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0003
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0004
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0005
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0006
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0007
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0008
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0009
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000A
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000B
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000C
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000D
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000E
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000F
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0010
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0011
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0012
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0013
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0014
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0015
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0016
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0017
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0018
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0019
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001A
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001B
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001C
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001D
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001E
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001F
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0020 (space)
  { 0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00},   // U+0021 (!)
  { 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0022 (")
  { 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00},   // U+0023 (#)
  { 0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00},   // U+0024 ($)
  { 0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00},   // U+0025 (%)
  { 0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00},   // U+0026 (&)
  { 0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0027 (')
  { 0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00},   // U+0028 (()
  { 0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00},   // U+0029 ())
  { 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00},   // U+002A (*)
  { 0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00},   // U+002B (+)
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+002C (,)
  { 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00},   // U+002D (-)
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+002E (.)
  { 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00},   // U+002F (/)
  { 0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00},   // U+0030 (0)
  { 0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00},   // U+0031 (1)
  { 0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00},   // U+0032 (2)
  { 0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00},   // U+0033 (3)
  { 0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00},   // U+0034 (4)
  { 0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00},   // U+0035 (5)
  { 0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00},   // U+0036 (6)
  { 0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00},   // U+0037 (7)
  { 0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00},   // U+0038 (8)
  { 0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00},   // U+0039 (9)
  { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+003A (:)
  { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+003B (//)
  { 0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00},   // U+003C (<)
  { 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00},   // U+003D (=)
  { 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00},   // U+003E (>)
  { 0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00},   // U+003F (?)
  { 0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00},   // U+0040 (@)
  { 0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00},   // U+0041 (A)
  { 0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00},   // U+0042 (B)
  { 0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00},   // U+0043 (C)
  { 0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00},   // U+0044 (D)
  { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00},   // U+0045 (E)
  { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00},   // U+0046 (F)
  { 0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00},   // U+0047 (G)
  { 0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00},   // U+0048 (H)
  { 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0049 (I)
  { 0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00},   // U+004A (J)
  { 0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00},   // U+004B (K)
  { 0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00},   // U+004C (L)
  { 0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00},   // U+004D (M)
  { 0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00},   // U+004E (N)
  { 0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00},   // U+004F (O)
  { 0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00},   // U+0050 (P)
  { 0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00},   // U+0051 (Q)
  { 0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00},   // U+0052 (R)
  { 0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00},   // U+0053 (S)
  { 0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0054 (T)
  { 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00},   // U+0055 (U)
  { 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0056 (V)
  { 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00},   // U+0057 (W)
  { 0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00},   // U+0058 (X)
  { 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00},   // U+0059 (Y)
  { 0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00},   // U+005A (Z)
  { 0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00},   // U+005B ([)
  { 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00},   // U+005C (\)
  { 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00},   // U+005D (])
  { 0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00},   // U+005E (^)
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},   // U+005F (_)
  { 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0060 (`)
  { 0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00},   // U+0061 (a)
  { 0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00},   // U+0062 (b)
  { 0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00},   // U+0063 (c)
  { 0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00},   // U+0064 (d)
  { 0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00},   // U+0065 (e)
  { 0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00},   // U+0066 (f)
  { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0067 (g)
  { 0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00},   // U+0068 (h)
  { 0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0069 (i)
  { 0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E},   // U+006A (j)
  { 0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00},   // U+006B (k)
  { 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+006C (l)
  { 0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00},   // U+006D (m)
  { 0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00},   // U+006E (n)
  { 0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00},   // U+006F (o)
  { 0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F},   // U+0070 (p)
  { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78},   // U+0071 (q)
  { 0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00},   // U+0072 (r)
  { 0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00},   // U+0073 (s)
  { 0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00},   // U+0074 (t)
  { 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00},   // U+0075 (u)
  { 0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0076 (v)
  { 0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00},   // U+0077 (w)
  { 0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00},   // U+0078 (x)
  { 0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0079 (y)
  { 0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00},   // U+007A (z)
  { 0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00},   // U+007B ({)
  { 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},   // U+007C (|)
  { 0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00},   // U+007D (})
  { 0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+007E (~)
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}    // U+007F
};

static uint8_t vga[0x30] = {
  0x00, 0x00, 0x00,
  0xAA, 0x00, 0x00,
  0x00, 0xAA, 0x00,
  0xAA, 0x55, 0x00,
  0x00, 0x00, 0xAA,
  0xAA, 0x00, 0xAA,
  0x00, 0xAA, 0xAA,
  0xAA, 0xAA, 0xAA,
  0x55, 0x55, 0x55,
  0xFF, 0x55, 0x55,
  0x55, 0xFF, 0x55,
  0xFF, 0xFF, 0x55,
  0x55, 0x55, 0xFF,
  0xFF, 0x55, 0xFF,
  0x55, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF,
};

struct Node {
  uint16_t key;
  struct Node *children[];
};
typedef struct Node Node;

static inline Node *
new_node(uint16_t key, int degree)
{
  Node *node = calloc(1, sizeof(*node) + degree * sizeof(Node *));
  if (node)
    node->key = key;
  return node;
}

static inline Node *
new_trie(int degree, int *nkeys)
{
  Node *root = new_node(0, degree);
  /* Create nodes for single pixels. */
  for (*nkeys = 0; *nkeys < degree; (*nkeys)++)
    root->children[*nkeys] = new_node(*nkeys, degree);
  *nkeys += 2; /* skip clear code and stop code */
  return root;
}

static inline void
del_trie(Node *root, int degree)
{
  if (!root)
    return;
  for (int i = 0; i < degree; i++)
    del_trie(root->children[i], degree);
  free(root);
}

static inline void put_loop(ge_GIF *gif, uint16_t loop);

ge_GIF *
ge_new_gif(
           const char *fname, uint16_t width, uint16_t height,
           uint8_t *palette, int depth, int loop
           )
{
  int i, r, g, b, v;
  ge_GIF *gif = calloc(1, sizeof(*gif) + 2*width*height);
  if (!gif)
    goto no_gif;
  gif->w = width; gif->h = height;
  gif->depth = depth > 1 ? depth : 2;
  gif->frame = (uint8_t *) &gif[1];
  gif->back = &gif->frame[width*height];
  gif->fd = creat(fname, 0666);
  if (gif->fd == -1)
    goto no_fd;
#ifdef _WIN32
  setmode(gif->fd, O_BINARY);
#endif
  write(gif->fd, "GIF89a", 6);
  write_num(gif->fd, width);
  write_num(gif->fd, height);
  write(gif->fd, (uint8_t []) {0xF0 | (depth-1), 0x00, 0x00}, 3);
  if (palette) {
    write(gif->fd, palette, 3 << depth);
  } else if (depth <= 4) {
    write(gif->fd, vga, 3 << depth);
  } else {
    write(gif->fd, vga, sizeof(vga));
    i = 0x10;
    for (r = 0; r < 6; r++) {
      for (g = 0; g < 6; g++) {
        for (b = 0; b < 6; b++) {
          write(gif->fd, (uint8_t []) {r*51, g*51, b*51}, 3);
          if (++i == 1 << depth)
            goto done_gct;
        }
      }
    }
    for (i = 1; i <= 24; i++) {
      v = i * 0xFF / 25;
      write(gif->fd, (uint8_t []) {v, v, v}, 3);
    }
  }
done_gct:
  if (loop >= 0 && loop <= 0xFFFF)
    put_loop(gif, (uint16_t) loop);
  return gif;
no_fd:
  free(gif);
no_gif:
  return NULL;
}

static inline void
put_loop(ge_GIF *gif, uint16_t loop)
{
  write(gif->fd, (uint8_t []) {'!', 0xFF, 0x0B}, 3);
  write(gif->fd, "NETSCAPE2.0", 11);
  write(gif->fd, (uint8_t []) {0x03, 0x01}, 2);
  write_num(gif->fd, loop);
  write(gif->fd, "\0", 1);
}

/* Add packed key to buffer, updating offset and partial.
 *   gif->offset holds position to put next *bit*
 *   gif->partial holds bits to include in next byte */
static inline void
put_key(ge_GIF *gif, uint16_t key, int key_size)
{
  int byte_offset, bit_offset, bits_to_write;
  byte_offset = gif->offset / 8;
  bit_offset = gif->offset % 8;
  gif->partial |= ((uint32_t) key) << bit_offset;
  bits_to_write = bit_offset + key_size;
  while (bits_to_write >= 8) {
    gif->buffer[byte_offset++] = gif->partial & 0xFF;
    if (byte_offset == 0xFF) {
      write(gif->fd, "\xFF", 1);
      write(gif->fd, gif->buffer, 0xFF);
      byte_offset = 0;
    }
    gif->partial >>= 8;
    bits_to_write -= 8;
  }
  gif->offset = (gif->offset + key_size) % (0xFF * 8);
}

static inline void
end_key(ge_GIF *gif)
{
  int byte_offset;
  byte_offset = gif->offset / 8;
  if (gif->offset % 8)
    gif->buffer[byte_offset++] = gif->partial & 0xFF;
  write(gif->fd, (uint8_t []) {byte_offset}, 1);
  write(gif->fd, gif->buffer, byte_offset);
  write(gif->fd, "\0", 1);
  gif->offset = gif->partial = 0;
}

static inline void
put_image(ge_GIF *gif, uint16_t w, uint16_t h, uint16_t x, uint16_t y)
{
  int nkeys, key_size, i, j;
  Node *node, *child, *root;
  int degree = 1 << gif->depth;
  
  write(gif->fd, ",", 1);
  write_num(gif->fd, x);
  write_num(gif->fd, y);
  write_num(gif->fd, w);
  write_num(gif->fd, h);
  write(gif->fd, (uint8_t []) {0x00, gif->depth}, 2);
  root = node = new_trie(degree, &nkeys);
  key_size = gif->depth + 1;
  put_key(gif, degree, key_size); /* clear code */
  for (i = y; i < y+h; i++) {
    for (j = x; j < x+w; j++) {
      uint8_t pixel = gif->frame[i*gif->w+j] & (degree - 1);
      child = node->children[pixel];
      if (child) {
        node = child;
      } else {
        put_key(gif, node->key, key_size);
        if (nkeys < 0x1000) {
          if (nkeys == (1 << key_size))
            key_size++;
          node->children[pixel] = new_node(nkeys++, degree);
        } else {
          put_key(gif, degree, key_size); /* clear code */
          del_trie(root, degree);
          root = node = new_trie(degree, &nkeys);
          key_size = gif->depth + 1;
        }
        node = root->children[pixel];
      }
    }
  }
  put_key(gif, node->key, key_size);
  put_key(gif, degree + 1, key_size); /* stop code */
  end_key(gif);
  del_trie(root, degree);
}

static inline int
get_bbox(ge_GIF *gif, uint16_t *w, uint16_t *h, uint16_t *x, uint16_t *y)
{
  int i, j, k;
  int left, right, top, bottom;
  left = gif->w; right = 0;
  top = gif->h; bottom = 0;
  k = 0;
  for (i = 0; i < gif->h; i++) {
    for (j = 0; j < gif->w; j++, k++) {
      if (gif->frame[k] != gif->back[k]) {
        if (j < left)   left    = j;
        if (j > right)  right   = j;
        if (i < top)    top     = i;
        if (i > bottom) bottom  = i;
      }
    }
  }
  if (left != gif->w && top != gif->h) {
    *x = left; *y = top;
    *w = right - left + 1;
    *h = bottom - top + 1;
    return 1;
  } else {
    return 0;
  }
}

static inline void
set_delay(ge_GIF *gif, uint16_t d)
{
  write(gif->fd, (uint8_t []) {'!', 0xF9, 0x04, 0x04}, 4);
  write_num(gif->fd, d);
  write(gif->fd, "\0\0", 2);
}

static inline void
ge_add_frame(ge_GIF *gif, uint16_t delay)
{
  uint16_t w, h, x, y;
  uint8_t *tmp;
  
  if (delay)
    set_delay(gif, delay);
  if (gif->nframes == 0) {
    w = gif->w;
    h = gif->h;
    x = y = 0;
  } else if (!get_bbox(gif, &w, &h, &x, &y)) {
    /* image's not changed; save one pixel just to add delay */
    w = h = 1;
    x = y = 0;
  }
  put_image(gif, w, h, x, y);
  gif->nframes++;
  tmp = gif->back;
  gif->back = gif->frame;
  gif->frame = tmp;
}

static inline void
ge_close_gif(ge_GIF* gif)
{
  write(gif->fd, ";", 1);
  close(gif->fd);
  free(gif);
}

#define sb_free   stb_sb_free
#define sb_push   stb_sb_push
#define sb_count  stb_sb_count
#define sb_add    stb_sb_add
#define sb_last   stb_sb_last

#define stb_sb_free(a)         ((a) ? free(stb__sbraw(a)),0 : 0)
#define stb_sb_push(a,v)       (stb__sbmaybegrow(a,1), (a)[stb__sbn(a)++] = (v))
#define stb_sb_count(a)        ((a) ? stb__sbn(a) : 0)
#define stb_sb_add(a,n)        (stb__sbmaybegrow(a,n), stb__sbn(a)+=(n), &(a)[stb__sbn(a)-(n)])
#define stb_sb_last(a)         ((a)[stb__sbn(a)-1])

#define stb__sbraw(a) ((int *) (a) - 2)
#define stb__sbm(a)   stb__sbraw(a)[0]
#define stb__sbn(a)   stb__sbraw(a)[1]

#define stb__sbneedgrow(a,n)  ((a)==0 || stb__sbn(a)+(n) >= stb__sbm(a))
#define stb__sbmaybegrow(a,n) (stb__sbneedgrow(a,(n)) ? stb__sbgrow(a,n) : 0)
#define stb__sbgrow(a,n)      (*((void **)&(a)) = stb__sbgrowf((a), (n), sizeof(*(a))))

#include <stdlib.h>

static void * stb__sbgrowf(void *arr, int increment, int itemsize)
{
  int dbl_cur = arr ? 2*stb__sbm(arr) : 0;
  int min_needed = stb_sb_count(arr) + increment;
  int m = dbl_cur > min_needed ? dbl_cur : min_needed;
  int *p = (int *) realloc(arr ? stb__sbraw(arr) : 0, itemsize * m + sizeof(int)*2);
  if (p) {
    if (!arr)
      p[1] = 0;
    p[0] = m;
    return p+2;
  } else {
#ifdef STRETCHY_BUFFER_OUT_OF_MEMORY
    STRETCHY_BUFFER_OUT_OF_MEMORY ;
#endif
    return (void *) (2*sizeof(int)); // try to force a NULL pointer exception later
  }
}

typedef COLOR* frame_t;
static frame_t* frames = NULL;
static frame_t frame = NULL;
static int gif_w = 0, gif_h = 0, gif_delay = 100;

#define XYSET(s, x, y, v) ((s)[(y) * gif_w + (x)] = (v))
#define XYGET(s, x, y) ((s)[(y) * gif_h + (x)])

static inline void clear_frame(COLOR col) {
  for (int x = 0; x < gif_w; ++x)
    for (int y = 0; y < gif_h; ++y)
      XYSET(frame, x, y, col);
}

static inline void init_gif(int w, int h) {
  gif_w = w;
  gif_h = h;
  frame = calloc(sizeof(int), gif_w * gif_h);
  clear_frame(BLACK);
}

static inline void add_frame(void) {
  frame_t copy = calloc(sizeof(int), gif_w * gif_h);
  memcpy(copy, frame, gif_w * gif_h * sizeof(COLOR));
  sb_push(frames, copy);
}

static inline void make_gif(const char* path) {
  if (!sb_count(frames))
    return;
  
  ge_GIF *gif = ge_new_gif("example.gif", gif_w, gif_h, color_map, 3, 0);
  
  for (int i = 0; i < sb_count(frames); ++i) {
    frame_t tmp = frames[i];
    for (int i = 0; i < gif_w * gif_h; ++i)
      gif->frame[i] = (int)tmp[i];
    ge_add_frame(gif, gif_delay);
  }
  
  ge_close_gif(gif);
  
  for (int i = 0; i < sb_count(frames); ++i)
    free(frames[i]);
  sb_free(frames);
}

void line(int x0, int y0, int x1, int y1, COLOR col) {
  int dx = abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
  int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
  int err = dx + dy, e2;
  
  for (;;) {
    XYSET(frame, x0, y0, col);
    e2 = 2 * err;
    
    if (e2 >= dy) {
      if (x0 == x1)
        break;
      err += dy;
      x0 += sx;
    }
    
    if (e2 <= dx) {
      if (y0 == y1)
        break;
      err += dx;
      y0 += sy;
    }
  }
}

void pset(int x, int y, COLOR c) {
  XYSET(frame, x, y, c);
}

COLOR pget(int x, int y) {
  return XYGET(frame, x, y);
}

void letter(unsigned char ch, unsigned int x, unsigned int y, int col) {
  if (ch >= 128 || ch < 0)
    ch = 0;
  for (int i = 0; i < 8; ++i)
    for (int j = 0; j < 8; ++j)
      if (font[ch][i] & 1 << j)
        XYSET(frame, x + j, y + i, col);
}

void string(unsigned int x, unsigned int y, COLOR col, const char* str) {
  int u = x, v = y;
  char* c = (char*)str;
  while (c != NULL && *c != '\0') {
    if (*c == '\n') {
      v += 10;
      u  = x;
    } else {
      letter(*c, u, v, col);
      u += 8;
    }
    ++c;
  }
}

void string_fmt(unsigned int x, unsigned int y, COLOR col, const char* fmt, ...) {
  char *buffer = NULL;
  size_t buffer_size = 0;
  
  va_list argptr;
  va_start(argptr, fmt);
  int length = vsnprintf(buffer, buffer_size, fmt, argptr);
  va_end(argptr);
  
  if (length + 1 > buffer_size) {
    buffer_size = length + 1;
    buffer = realloc(buffer, buffer_size);
    va_start(argptr, fmt);
    vsnprintf(buffer, buffer_size, fmt, argptr);
    va_end(argptr);
  }
  
  string(x, y, col, buffer);
  free(buffer);
}

#endif /* GIF_HEADER_H */
